<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Mmloader by tishion</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Mmloader</h1>
      <h2 class="project-tagline">Lirary for loading dll module bypassing windows PE loader support x86/x64</h2>
      <a href="https://github.com/tishion/mmLoader" class="btn">View on GitHub</a>
      <a href="https://github.com/tishion/mmLoader/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/tishion/mmLoader/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="0x01-what-is-mmloader" class="anchor" href="#0x01-what-is-mmloader" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>0x01 What is mmLoader</h2>

<p>mmLoader is a stable library for loading PE module bypassing windows PE loader. mmLoader support x86/x64 Windows.</p>

<h2>
<a id="0x02-how-to-user-mmloader" class="anchor" href="#0x02-how-to-user-mmloader" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>0x02 How to user mmLoader</h2>

<h4>
<a id="use-mmloader-as-source-code-or-static-library" class="anchor" href="#use-mmloader-as-source-code-or-static-library" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use mmLoader as source code or static library</h4>

<p>Include the all the files in src/mmLoader folder into your proejects. Or you can build the source code to static library and add reference to it in your projects.</p>

<p>In these two ways you can use the mmLoader APIs:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Loads the memory module.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-c">/// &lt;param name="pMemModule"&gt;The &lt;see cref="MemModule" /&gt; instance.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="lpPeModuleBuffer"&gt;The buffer containing the raw data of the module.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="bCallEntry"&gt;Call the module entry if true.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;returns&gt;True if the module is loaded successfully.&lt;/returns&gt;</span>
BOOL __stdcall
<span class="pl-en">LoadMemModule</span>(
    _Out_ PMEM_MODULE pMemModule,
    _In_ LPVOID lpPeModuleBuffer, 
    _In_ BOOL bCallEntry);

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Gets the process address of the specific function in the memory module.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-c">/// &lt;param name="pMemModule"&gt;The &lt;see cref="MemModule" /&gt; instance.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="lpName"&gt;The function name.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;returns&gt;The address of the function or null.&lt;/returns&gt;</span>
FARPROC __stdcall
<span class="pl-en">GetMemModuleProc</span>(
    _Out_ PMEM_MODULE pMemModule,
    _In_ LPCSTR lpName);

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Frees the memory module.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-c">/// &lt;param name="pMemModule"&gt;The &lt;see cref="MemModule" /&gt; instance.&lt;/param&gt;</span>
VOID __stdcall
<span class="pl-en">FreeMemModule</span>(_Out_ PMEM_MODULE pMemModule);</pre></div>

<h4>
<a id="use-mmloader-as-shell-code" class="anchor" href="#use-mmloader-as-shell-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use mmLoader as shell code</h4>

<p>If you want to hide the code mmLoader, you can choose to use mmLoader as shell code. Just build the project <strong>mmLoader-shellcode-generator</strong> and then run it you will get the single header file of mmLoaderShellCode.h:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-c">/************************************************************************/</span>
<span class="pl-c">/* </span>
<span class="pl-c"> * This file is generated by mmLoaderShellCode Generator (x86)</span>
<span class="pl-c"> * Target platform: 32 bit windows application</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * https://github.com/tishion </span>
<span class="pl-c"> *</span>
<span class="pl-c">/************************************************************************/</span>
#<span class="pl-k">ifndef</span> __MMLOADER_H_INCLUDED_
#<span class="pl-k">define</span> <span class="pl-en">__MMLOADER_H_INCLUDED_</span>
#<span class="pl-k">pragma</span> once
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>windows.h<span class="pl-pds">&gt;</span></span>

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Error codes.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_OK</span>                           <span class="pl-c1">0</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_BAD_PE_FORMAT</span>                <span class="pl-c1">1</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_ALLOCATED_MEMORY_FAILED</span>      <span class="pl-c1">2</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_INVALID_RELOCATION_BASE</span>      <span class="pl-c1">3</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_IMPORT_MODULE_FAILED</span>         <span class="pl-c1">4</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_PROTECT_SECTION_FAILED</span>       <span class="pl-c1">5</span>
#<span class="pl-k">define</span> <span class="pl-en">MMEC_INVALID_ENTRY_POINT</span>          <span class="pl-c1">6</span>

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Function table. These function will be used in the mmLoader.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-en">__NTFUNCPTRS</span>
{
    LPVOID pfnGetModuleHandleA;           <span class="pl-c">// GetModuleHandleA</span>
    LPVOID pfnLoadLibraryA;               <span class="pl-c">// LoadLibraryA</span>
    LPVOID pfnGetProcAddress;             <span class="pl-c">// GetProcAddress</span>
    LPVOID pfnVirtualAlloc;               <span class="pl-c">// VirtualAlloc</span>
    LPVOID pfnVirtualFree;                <span class="pl-c">// VirtualFree</span>
    LPVOID pfnVirtualProtect;             <span class="pl-c">// VirtualProtect</span>
    LPVOID pfnReversed_0;
    LPVOID pfnReversed_1;
    LPVOID pfnReversed_2;
    LPVOID pfnReversed_3;
    LPVOID pfnReversed_4;
} NTFUNCPTRSTABLE, *PNTFUNCPTRSTABLE;

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Represents the memory module instance.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-k">typedef</span> <span class="pl-k">struct</span> <span class="pl-en">__MEMMODULE</span>
{
    <span class="pl-k">union</span>                                <span class="pl-c">// MemModule base</span>
    {
#<span class="pl-k">if</span> _WIN64
        ULONGLONG    iBase;
#<span class="pl-k">else</span>
        DWORD        iBase;
#<span class="pl-k">endif</span>
        HMODULE        hModule;
        LPVOID        lpBase;
        PIMAGE_DOS_HEADER pImageDosHeader;
    };

    DWORD dwSizeOfImage;                <span class="pl-c">// MemModule size</span>
    DWORD dwCrc;                        <span class="pl-c">// MemModule crc32</span>
    DWORD dwPageSize;                   <span class="pl-c">// SystemPageSize</span>
    BOOL  bLoadOk;                      <span class="pl-c">// MemModule is loaded ok?</span>

    PNTFUNCPTRSTABLE pNtFuncptrsTable;  <span class="pl-c">// Pointer to NT function pointers table </span>

    DWORD  dwErrorCode;                 <span class="pl-c">// Last error code</span>

    <span class="pl-en">__MEMMODULE</span>()
    {
        iBase = <span class="pl-c1">0</span>;
        dwSizeOfImage = <span class="pl-c1">0</span>;
        dwCrc = <span class="pl-c1">0</span>;
        bLoadOk = <span class="pl-c1">0</span>;
        pNtFuncptrsTable = <span class="pl-c1">0</span>;
        dwErrorCode = <span class="pl-c1">0</span>;

        SYSTEM_INFO sysInfo;
        <span class="pl-en">::GetNativeSystemInfo</span>(&amp;sysInfo);
        dwPageSize = sysInfo.<span class="pl-smi">dwPageSize</span>;
    }
} MEM_MODULE, *PMEM_MODULE;

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Enums for MemModuleHelper.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-k">typedef</span> <span class="pl-k">enum</span> _MMHELPER_METHOD
{
    MHM_BOOL_LOAD,
    MHM_VOID_FREE,
    MHM_FARPROC_GETPROC,
} MMHELPER_METHOD;

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// Helper function for using shell code.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-c">/// &lt;param name="pMemModule"&gt;The &lt;see cref="MemModule" /&gt; instance.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="method"&gt;The &lt;see cref="MMHELPER_METHOD"&gt; to call.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="lpPeModuleBuffer"&gt;The buffer containing the raw data of the module.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;param name="lpName"&gt;The function name.&lt;/param&gt;</span>
<span class="pl-c">/// &lt;returns&gt;True if the module is loaded successfully.&lt;/returns&gt;</span>
<span class="pl-c">/// &lt;returns&gt;</span>
<span class="pl-c">/// If method is MHM_BOOL_LOAD:</span>
<span class="pl-c">///        The return value type is BOOL.</span>
<span class="pl-c">///</span>
<span class="pl-c">/// If method is MHM_FARPROC_GETPROC</span>
<span class="pl-c">///        The return value type if FARPROC.</span>
<span class="pl-c">///</span>
<span class="pl-c">/// If method is MHM_VOID_FREE</span>
<span class="pl-c">///        There is no return value.</span>
<span class="pl-c">/// &lt;/returns&gt;</span>
<span class="pl-k">typedef</span> <span class="pl-en">LPVOID</span>(__stdcall * Type_MemModuleHelper)(PMEM_MODULE, MMHELPER_METHOD, LPVOID, LPCSTR, BOOL);

<span class="pl-c">/// &lt;summary&gt;</span>
<span class="pl-c">/// The byte array of the mmLoader shell code.</span>
<span class="pl-c">/// &lt;/summary&gt;</span>
<span class="pl-k">unsigned</span> <span class="pl-k">char</span> mmLoaderShellCode[] =
{
    0x55, 0x8B, 0xEC, 0x51, 0x8B, 0x45, 0x0C, 0x89, 0x45, 0xFC, 0x83, 0x7D, 0xFC, 0x00, 0x74, 0x0E, 
    ......
    ......
};

#<span class="pl-k">endif</span> <span class="pl-c">// __MMLOADERSHELLCODE_H_INCLUDED_</span></pre></div>

<p>Then include this header file into your project and use it like this:</p>

<div class="highlight highlight-source-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>windows.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>tchar.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>strsafe.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>mmLoaderShellCode.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
    <span class="pl-k">int</span> iRet = -<span class="pl-c1">1</span>;

    <span class="pl-c">// Initialize function table</span>
    NTFUNCPTRSTABLE <span class="pl-smi">sNtFuncPtrsTable</span>;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnGetModuleHandleA</span> = ::GetModuleHandleA;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnLoadLibraryA</span> = ::LoadLibraryA;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnGetProcAddress</span> = ::GetProcAddress;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnVirtualAlloc</span> = ::VirtualAlloc;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnVirtualFree</span> = ::VirtualFree;
    <span class="pl-smi">sNtFuncPtrsTable</span>.<span class="pl-smi">pfnVirtualProtect</span> = ::VirtualProtect;

    <span class="pl-c">// Memory module</span>
    MEM_MODULE <span class="pl-smi">sMemModule</span>;
    <span class="pl-smi">sMemModule</span>.<span class="pl-smi">pNtFuncptrsTable</span> = &amp;<span class="pl-smi">sNtFuncPtrsTable</span>;

    <span class="pl-c">// Allocate memory buffer for shell code with EXECUTE privilege</span>
    LPVOID  lpShellCodeBase = ::<span class="pl-c1">VirtualAlloc</span>(
        <span class="pl-c1">NULL</span>,
        <span class="pl-k">sizeof</span>(mmLoaderShellCode),
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == lpShellCodeBase)
    {
        <span class="pl-en">::_tprintf</span>(_T(<span class="pl-s"><span class="pl-pds">"</span>Failed to allocate space for ShellCode!<span class="pl-pds">"</span></span>));
        <span class="pl-k">return</span> iRet;
    }

    <span class="pl-c">// Copy shell code to the executable memory buffer</span>
    <span class="pl-en">::RtlCopyMemory</span>(lpShellCodeBase, mmLoaderShellCode, <span class="pl-k">sizeof</span>(mmLoaderShellCode));

    <span class="pl-c">// Get the helper function </span>
    Type_MemModuleHelper pfnMemModuleHelper = (Type_MemModuleHelper)lpShellCodeBase;

    <span class="pl-c">// Load the module</span>
#<span class="pl-k">ifdef</span> _DEBUG
    WCHAR wszDllPath[] = <span class="pl-s"><span class="pl-pds">L"</span>demo-moduled.dll<span class="pl-pds">"</span></span>;
#<span class="pl-k">else</span>
    WCHAR wszDllPath[] = <span class="pl-s"><span class="pl-pds">L"</span>demo-module.dll<span class="pl-pds">"</span></span>;
#<span class="pl-k">endif</span>

    <span class="pl-c">// Open the module and read it into memory buffer</span>
    BOOL br = <span class="pl-c1">FALSE</span>;
    HANDLE hFile = ::<span class="pl-c1">CreateFileW</span>(wszDllPath, GENERIC_READ, FILE_SHARE_READ, <span class="pl-c1">NULL</span>, OPEN_EXISTING, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">if</span> (INVALID_HANDLE_VALUE == hFile || <span class="pl-c1">NULL</span> == hFile)
    {
        <span class="pl-c1">wprintf</span>(<span class="pl-s"><span class="pl-pds">L"</span>Failed to open the file: %s<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, wszDllPath);
        <span class="pl-k">return</span> iRet;
    }

    <span class="pl-c">// Check file size</span>
    DWORD dwFileSize = ::<span class="pl-c1">GetFileSize</span>(hFile, <span class="pl-c1">NULL</span>);
    <span class="pl-k">if</span> (INVALID_FILE_SIZE == dwFileSize || dwFileSize &lt; <span class="pl-k">sizeof</span>(IMAGE_DOS_HEADER))
    {
        <span class="pl-en">::CloseHandle</span>(hFile);
        <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid file size: %d<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>), dwFileSize);
        <span class="pl-k">return</span> iRet;
    }

    HANDLE hFileMapping = ::<span class="pl-c1">CreateFileMappingW</span>(hFile, <span class="pl-c1">0</span>, PAGE_READONLY, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>);
    <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == hFileMapping)
    {
        <span class="pl-en">::CloseHandle</span>(hFile);
        <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Failed to create file mapping.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>));
        <span class="pl-k">return</span> iRet;
    }

    LPVOID pBuffer = ::<span class="pl-c1">MapViewOfFile</span>(hFileMapping, FILE_MAP_READ, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
    <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == pBuffer)
    {
        <span class="pl-en">::CloseHandle</span>(hFileMapping);
        <span class="pl-en">::CloseHandle</span>(hFile);
        <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Failed to map view of the file.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>));
        <span class="pl-k">return</span> iRet;
    }

    <span class="pl-k">if</span> (<span class="pl-c1">pfnMemModuleHelper</span>(&amp;<span class="pl-smi">sMemModule</span>, MHM_BOOL_LOAD, pBuffer, <span class="pl-c1">NULL</span>, <span class="pl-c1">FALSE</span>))
    {
        <span class="pl-en">::UnmapViewOfFile</span>(pBuffer);
        <span class="pl-en">::CloseHandle</span>(hFileMapping);
        <span class="pl-en">::CloseHandle</span>(hFile);

        <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Module was load successfully. Module Base: 0x%p!<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>), <span class="pl-smi">sMemModule</span>.<span class="pl-smi">lpBase</span>);

        <span class="pl-c">// Get address of function demoFunction</span>
        LPVOID lpAddr = (LPVOID)<span class="pl-c1">pfnMemModuleHelper</span>(&amp;<span class="pl-smi">sMemModule</span>, MHM_FARPROC_GETPROC, <span class="pl-c1">NULL</span>, <span class="pl-s"><span class="pl-pds">"</span>demoFunction<span class="pl-pds">"</span></span>, <span class="pl-c1">FALSE</span>);
        <span class="pl-k">if</span> (lpAddr)
        {
            <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Get address of demoFunction successfully. Address: 0x%p!<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>), lpAddr);

            <span class="pl-c">// Function pointer type of demoFunction</span>
            <span class="pl-k">typedef</span> <span class="pl-smi">BOOL</span>(__stdcall * Type_TargetFunction)(<span class="pl-k">unsigned</span> <span class="pl-k">char</span>*, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>);

            <span class="pl-c">// Call the demoFunction</span>
            Type_TargetFunction pfnFunction = (Type_TargetFunction)lpAddr;

            <span class="pl-k">unsigned</span> <span class="pl-k">char</span> buf[MAX_PATH] = { <span class="pl-c1">0</span> };
            <span class="pl-k">if</span> (<span class="pl-c1">pfnFunction</span>(buf, MAX_PATH))
            {
                <span class="pl-k">char</span>* p = <span class="pl-s"><span class="pl-pds">"</span>{f56fee02-16d1-44a3-b191-4d7535f92ca5}<span class="pl-pds">"</span></span>;
                iRet = ::<span class="pl-c1">memcmp</span>(buf, p, <span class="pl-c1">strlen</span>(p));
                <span class="pl-k">if</span> (<span class="pl-c1">0</span> == iRet)
                    <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Called target function demoFunction successfully with correct return value!<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>));
                <span class="pl-k">else</span>
                    <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Called target function demoFunction successfully, but returned unexpected value!<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>));
            }
        }
        <span class="pl-k">else</span>
            <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Failed to get address of MessageBoxA from memory module.<span class="pl-pds">"</span></span>));

        <span class="pl-c">// Free the module</span>
        <span class="pl-c1">pfnMemModuleHelper</span>(&amp;<span class="pl-smi">sMemModule</span>, MHM_VOID_FREE, <span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, <span class="pl-c1">FALSE</span>);
    }
    <span class="pl-k">else</span>
        <span class="pl-c1">_tprintf</span>(<span class="pl-c1">_T</span>(<span class="pl-s"><span class="pl-pds">"</span>Failed to load user32.dll!<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>));

    <span class="pl-c">// Free the memory buffer of the shell code</span>
    <span class="pl-en">::VirtualFree</span>(lpShellCodeBase, <span class="pl-c1">0</span>, MEM_RELEASE);

    <span class="pl-k">return</span> iRet;
}</pre></div>

<h2>
<a id="0x03-is-there-any-limitation-" class="anchor" href="#0x03-is-there-any-limitation-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>0x03 Is there any limitation ?</h2>

<p>No. Feel free to use this library. :)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/tishion/mmLoader">Mmloader</a> is maintained by <a href="https://github.com/tishion">tishion</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
