{
  "name": "Mmloader",
  "tagline": "Lirary for loading dll module bypassing windows PE loader support x86/x64",
  "body": "## 0x01 What is mmLoader\r\nmmLoader is a stable library for loading PE module bypassing windows PE loader. mmLoader supports x86/x64 Windows.\r\n\r\n## 0x02 How to use mmLoader\r\n\r\n#### Use mmLoader as source code or static library\r\nInclude all the files in src/mmLoader folder into your proejects. Or you can build the source code to static library and add reference to it in your projects.\r\n\r\nIn these two ways you can use the mmLoader APIs:\r\n```cpp\r\n/// <summary>\r\n/// Loads the memory module.\r\n/// </summary>\r\n/// <param name=\"pMemModule\">The <see cref=\"MemModule\" /> instance.</param>\r\n/// <param name=\"lpPeModuleBuffer\">The buffer containing the raw data of the module.</param>\r\n/// <param name=\"bCallEntry\">Call the module entry if true.</param>\r\n/// <returns>True if the module is loaded successfully.</returns>\r\nBOOL __stdcall\r\nLoadMemModule(\r\n\t_Out_ PMEM_MODULE pMemModule,\r\n\t_In_ LPVOID lpPeModuleBuffer, \r\n\t_In_ BOOL bCallEntry);\r\n\r\n/// <summary>\r\n/// Gets the process address of the specific function in the memory module.\r\n/// </summary>\r\n/// <param name=\"pMemModule\">The <see cref=\"MemModule\" /> instance.</param>\r\n/// <param name=\"lpName\">The function name.</param>\r\n/// <returns>The address of the function or null.</returns>\r\nFARPROC __stdcall\r\nGetMemModuleProc(\r\n\t_Out_ PMEM_MODULE pMemModule,\r\n\t_In_ LPCSTR lpName);\r\n\r\n/// <summary>\r\n/// Frees the memory module.\r\n/// </summary>\r\n/// <param name=\"pMemModule\">The <see cref=\"MemModule\" /> instance.</param>\r\nVOID __stdcall\r\nFreeMemModule(_Out_ PMEM_MODULE pMemModule);\r\n```\r\n\r\n#### Use mmLoader as shell code\r\nIf you want to hide the code of mmLoader, you can choose to use mmLoader as shell code. Just build the project **mmLoader-shellcode-generator** and then run it you will get the single header file of mmLoaderShellCode.h:\r\n```cpp\r\n/************************************************************************/\r\n/* \r\n * This file is generated by mmLoaderShellCode Generator (x86)\r\n * Target platform: 32 bit windows application\r\n *\r\n * https://github.com/tishion \r\n *\r\n/************************************************************************/\r\n#ifndef __MMLOADER_H_INCLUDED_\r\n#define __MMLOADER_H_INCLUDED_\r\n#pragma once\r\n#include <windows.h>\r\n\r\n/// <summary>\r\n/// Error codes.\r\n/// </summary>\r\n#define MMEC_OK                           0\r\n#define MMEC_BAD_PE_FORMAT                1\r\n#define MMEC_ALLOCATED_MEMORY_FAILED      2\r\n#define MMEC_INVALID_RELOCATION_BASE      3\r\n#define MMEC_IMPORT_MODULE_FAILED         4\r\n#define MMEC_PROTECT_SECTION_FAILED       5\r\n#define MMEC_INVALID_ENTRY_POINT          6\r\n\r\n/// <summary>\r\n/// Function table. These function will be used in the mmLoader.\r\n/// </summary>\r\ntypedef struct __NTFUNCPTRS\r\n{\r\n    LPVOID pfnGetModuleHandleA;           // GetModuleHandleA\r\n    LPVOID pfnLoadLibraryA;               // LoadLibraryA\r\n    LPVOID pfnGetProcAddress;             // GetProcAddress\r\n    LPVOID pfnVirtualAlloc;               // VirtualAlloc\r\n    LPVOID pfnVirtualFree;                // VirtualFree\r\n    LPVOID pfnVirtualProtect;             // VirtualProtect\r\n    LPVOID pfnReversed_0;\r\n    LPVOID pfnReversed_1;\r\n    LPVOID pfnReversed_2;\r\n    LPVOID pfnReversed_3;\r\n    LPVOID pfnReversed_4;\r\n} NTFUNCPTRSTABLE, *PNTFUNCPTRSTABLE;\r\n\r\n/// <summary>\r\n/// Represents the memory module instance.\r\n/// </summary>\r\ntypedef struct __MEMMODULE\r\n{\r\n    union                                // MemModule base\r\n    {\r\n#if _WIN64\r\n        ULONGLONG    iBase;\r\n#else\r\n        DWORD        iBase;\r\n#endif\r\n        HMODULE        hModule;\r\n        LPVOID        lpBase;\r\n        PIMAGE_DOS_HEADER pImageDosHeader;\r\n    };\r\n\r\n    DWORD dwSizeOfImage;                // MemModule size\r\n    DWORD dwCrc;                        // MemModule crc32\r\n    DWORD dwPageSize;                   // SystemPageSize\r\n    BOOL  bLoadOk;                      // MemModule is loaded ok?\r\n\r\n    PNTFUNCPTRSTABLE pNtFuncptrsTable;  // Pointer to NT function pointers table \r\n\r\n    DWORD  dwErrorCode;                 // Last error code\r\n\r\n    __MEMMODULE()\r\n    {\r\n        iBase = 0;\r\n        dwSizeOfImage = 0;\r\n        dwCrc = 0;\r\n        bLoadOk = 0;\r\n        pNtFuncptrsTable = 0;\r\n        dwErrorCode = 0;\r\n        \r\n        SYSTEM_INFO sysInfo;\r\n        ::GetNativeSystemInfo(&sysInfo);\r\n        dwPageSize = sysInfo.dwPageSize;\r\n    }\r\n} MEM_MODULE, *PMEM_MODULE;\r\n\r\n/// <summary>\r\n/// Enums for MemModuleHelper.\r\n/// </summary>\r\ntypedef enum _MMHELPER_METHOD\r\n{\r\n    MHM_BOOL_LOAD,\r\n    MHM_VOID_FREE,\r\n    MHM_FARPROC_GETPROC,\r\n} MMHELPER_METHOD;\r\n\r\n/// <summary>\r\n/// Helper function for using shell code.\r\n/// </summary>\r\n/// <param name=\"pMemModule\">The <see cref=\"MemModule\" /> instance.</param>\r\n/// <param name=\"method\">The <see cref=\"MMHELPER_METHOD\"> to call.</param>\r\n/// <param name=\"lpPeModuleBuffer\">The buffer containing the raw data of the module.</param>\r\n/// <param name=\"lpName\">The function name.</param>\r\n/// <returns>True if the module is loaded successfully.</returns>\r\n/// <returns>\r\n/// If method is MHM_BOOL_LOAD:\r\n///        The return value type is BOOL.\r\n///\r\n/// If method is MHM_FARPROC_GETPROC\r\n///        The return value type if FARPROC.\r\n///\r\n/// If method is MHM_VOID_FREE\r\n///        There is no return value.\r\n/// </returns>\r\ntypedef LPVOID(__stdcall * Type_MemModuleHelper)(PMEM_MODULE, MMHELPER_METHOD, LPVOID, LPCSTR, BOOL);\r\n\r\n/// <summary>\r\n/// The byte array of the mmLoader shell code.\r\n/// </summary>\r\nunsigned char mmLoaderShellCode[] =\r\n{\r\n    0x55, 0x8B, 0xEC, 0x51, 0x8B, 0x45, 0x0C, 0x89, 0x45, 0xFC, 0x83, 0x7D, 0xFC, 0x00, 0x74, 0x0E, \r\n    ......\r\n    ......\r\n};\r\n\r\n#endif // __MMLOADERSHELLCODE_H_INCLUDED_\r\n```\r\nThen include this header file into your project and use it like this:\r\n```cpp\r\n#include <windows.h>\r\n#include <tchar.h>\r\n#include <strsafe.h>\r\n#include \"mmLoaderShellCode.h\"\r\n\r\nint main()\r\n{\r\n\tint iRet = -1;\r\n\r\n\t// Initialize function table\r\n\tNTFUNCPTRSTABLE sNtFuncPtrsTable;\r\n\tsNtFuncPtrsTable.pfnGetModuleHandleA = ::GetModuleHandleA;\r\n\tsNtFuncPtrsTable.pfnLoadLibraryA = ::LoadLibraryA;\r\n\tsNtFuncPtrsTable.pfnGetProcAddress = ::GetProcAddress;\r\n\tsNtFuncPtrsTable.pfnVirtualAlloc = ::VirtualAlloc;\r\n\tsNtFuncPtrsTable.pfnVirtualFree = ::VirtualFree;\r\n\tsNtFuncPtrsTable.pfnVirtualProtect = ::VirtualProtect;\r\n\r\n\t// Memory module\r\n\tMEM_MODULE sMemModule;\r\n\tsMemModule.pNtFuncptrsTable = &sNtFuncPtrsTable;\r\n\r\n\t// Allocate memory buffer for shell code with EXECUTE privilege\r\n\tLPVOID  lpShellCodeBase = ::VirtualAlloc(\r\n\t\tNULL,\r\n\t\tsizeof(mmLoaderShellCode),\r\n\t\tMEM_RESERVE | MEM_COMMIT,\r\n\t\tPAGE_EXECUTE_READWRITE);\r\n\r\n\tif (NULL == lpShellCodeBase)\r\n\t{\r\n\t\t::_tprintf(_T(\"Failed to allocate space for ShellCode!\"));\r\n\t\treturn iRet;\r\n\t}\r\n\r\n\t// Copy shell code to the executable memory buffer\r\n\t::RtlCopyMemory(lpShellCodeBase, mmLoaderShellCode, sizeof(mmLoaderShellCode));\r\n\r\n\t// Get the helper function \r\n\tType_MemModuleHelper pfnMemModuleHelper = (Type_MemModuleHelper)lpShellCodeBase;\r\n\r\n\t// Load the module\r\n#ifdef _DEBUG\r\n\tWCHAR wszDllPath[] = L\"demo-moduled.dll\";\r\n#else\r\n\tWCHAR wszDllPath[] = L\"demo-module.dll\";\r\n#endif\r\n\r\n\t// Open the module and read it into memory buffer\r\n\tBOOL br = FALSE;\r\n\tHANDLE hFile = ::CreateFileW(wszDllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);\r\n\tif (INVALID_HANDLE_VALUE == hFile || NULL == hFile)\r\n\t{\r\n\t\twprintf(L\"Failed to open the file: %s\\r\\n\", wszDllPath);\r\n\t\treturn iRet;\r\n\t}\r\n\r\n\t// Check file size\r\n\tDWORD dwFileSize = ::GetFileSize(hFile, NULL);\r\n\tif (INVALID_FILE_SIZE == dwFileSize || dwFileSize < sizeof(IMAGE_DOS_HEADER))\r\n\t{\r\n\t\t::CloseHandle(hFile);\r\n\t\t_tprintf(_T(\"Invalid file size: %d\\r\\n\"), dwFileSize);\r\n\t\treturn iRet;\r\n\t}\r\n\r\n\tHANDLE hFileMapping = ::CreateFileMappingW(hFile, 0, PAGE_READONLY, 0, 0, NULL);\r\n\tif (NULL == hFileMapping)\r\n\t{\r\n\t\t::CloseHandle(hFile);\r\n\t\t_tprintf(_T(\"Failed to create file mapping.\\r\\n\"));\r\n\t\treturn iRet;\r\n\t}\r\n\r\n\tLPVOID pBuffer = ::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);\r\n\tif (NULL == pBuffer)\r\n\t{\r\n\t\t::CloseHandle(hFileMapping);\r\n\t\t::CloseHandle(hFile);\r\n\t\t_tprintf(_T(\"Failed to map view of the file.\\r\\n\"));\r\n\t\treturn iRet;\r\n\t}\r\n\r\n\tif (pfnMemModuleHelper(&sMemModule, MHM_BOOL_LOAD, pBuffer, NULL, FALSE))\r\n\t{\r\n\t\t::UnmapViewOfFile(pBuffer);\r\n\t\t::CloseHandle(hFileMapping);\r\n\t\t::CloseHandle(hFile);\r\n\r\n\t\t_tprintf(_T(\"Module was load successfully. Module Base: 0x%p!\\r\\n\"), sMemModule.lpBase);\r\n\r\n\t\t// Get address of function demoFunction\r\n\t\tLPVOID lpAddr = (LPVOID)pfnMemModuleHelper(&sMemModule, MHM_FARPROC_GETPROC, NULL, \"demoFunction\", FALSE);\r\n\t\tif (lpAddr)\r\n\t\t{\r\n\t\t\t_tprintf(_T(\"Get address of demoFunction successfully. Address: 0x%p!\\r\\n\"), lpAddr);\r\n\r\n\t\t\t// Function pointer type of demoFunction\r\n\t\t\ttypedef BOOL(__stdcall * Type_TargetFunction)(unsigned char*, unsigned int);\r\n\r\n\t\t\t// Call the demoFunction\r\n\t\t\tType_TargetFunction pfnFunction = (Type_TargetFunction)lpAddr;\r\n\r\n\t\t\tunsigned char buf[MAX_PATH] = { 0 };\r\n\t\t\tif (pfnFunction(buf, MAX_PATH))\r\n\t\t\t{\r\n\t\t\t\tchar* p = \"{f56fee02-16d1-44a3-b191-4d7535f92ca5}\";\r\n\t\t\t\tiRet = ::memcmp(buf, p, strlen(p));\r\n\t\t\t\tif (0 == iRet)\r\n\t\t\t\t\t_tprintf(_T(\"Called target function demoFunction successfully with correct return value!\\r\\n\"));\r\n\t\t\t\telse\r\n\t\t\t\t\t_tprintf(_T(\"Called target function demoFunction successfully, but returned unexpected value!\\r\\n\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\t_tprintf(_T(\"Failed to get address of MessageBoxA from memory module.\"));\r\n\r\n\t\t// Free the module\r\n\t\tpfnMemModuleHelper(&sMemModule, MHM_VOID_FREE, NULL, NULL, FALSE);\r\n\t}\r\n\telse\r\n\t\t_tprintf(_T(\"Failed to load user32.dll!\\r\\n\"));\r\n\r\n\t// Free the memory buffer of the shell code\r\n\t::VirtualFree(lpShellCodeBase, 0, MEM_RELEASE);\r\n\r\n\treturn iRet;\r\n}\r\n```\r\n\r\n## 0x03 Is there any limitation ?\r\nNo. Feel free to use this library. :)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}